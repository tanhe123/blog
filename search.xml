<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用原理视角看 Git]]></title>
    <url>%2F2016%2F07%2F05%2Fgit-implement%2F</url>
    <content type="text"><![CDATA[1. 开始大家下午好，欢迎大家来到 Coding 技术小馆，我叫谭贺贺，目前我在Coding 主要负责 WebIDE 与 Codeinsight 的开发。我今天带来的主要内容是 git 的原理与使用。 谈起 git，大家的第一印象无非是和 svn 一样的版本控制系统，但其实，他们有着非常大的不同，至少 svn 没有像git一样这么多的玩法。下面我举几个例子，简略的说一下。 1.1 搭建博客阮一峰将写 blog 的人分成三个阶段 使用免费空间，比如 CSDN、博客园。发现免费空间限制太多，于是自己购买域名和空间，搭建独立博客。独立博客管理太麻烦，最好在保留控制权的前提下，让别人来管，自己负责写文章。 其实第三种阶段指的就是使用 Pages 服务。很多公司比如 Coding、Github 等代码托管平台都推出了 Pages 服务，可以用来搭建个人博客。Pages 服务不需要复杂的配置，就可以完成博客的搭建。 在使用 Pages 的过程中，通过使用标记语言（Markdown）完成博客的编写，推送到服务器上，就可以看到新发布的博客了。 不需要管理服务器，降低了搭建博客的门槛，同时又保持了用户对博客的高度定制权。 1.2 写书很多牛人喜欢写博客，博客写多了，然后汇集起来就出了本书。比如 Matrix67《思考的乐趣》、阮一峰《如何变得有思想》就是这样的例子。 其实出书距离我们也并不遥远，为什么？因为有 gitbook 这类服务。 对于 git + Pages 服务的用户，gitbook 很容易上手，因为使用 gitbook 就是使用 git 与 markdown。你完全可以将你 markdown 的博客 copy，汇集起来，形成一本书籍。内容的排版 gitbook 会帮你做，我们只负责内容就可以了。编写好内容，我们就能立刻获得 html、pdf、epub、mobi 四个版本的电子书。这是 html 版的预览： 在 gitbook 上有 explore 频道，上面列出了所有公开的书籍（当然也可以直接搜索）。 实际上，除了写书，还可以连同其他人一起进行外文资料的翻译，举个例子《The Swift Programming Language》中文版，将英文版分成几个部分，然后在开源项目中由参与者认领翻译，每个人贡献一份自己的力量，完成了这样以非常快的相应速度跟随官方文档更新的操作。如果你喜欢的一门语言，或者技术，中文资料缺乏，大家可以发起这样的活动，完成外文资料的翻译。 1.3 人才招聘人才招聘这一块，至今还并没有形成一定的规模。但仍旧有很多的公司选择在代码托管平台上（比如 Coding、Github）上寻找中意的开发者。 有一些开发者看准了这一块，专门开发了这样的网站，比如 githuber.cn、github-awards.com。 拿 githuber 举例，该网站主要提供两个功能，第一个是星榜，说白了将所有所有用户按照语言分类，然后根据粉丝数（star）排序。 我们可以很容易的看到排行榜上前几位的用户，他们的开源项目，这在一定程度上能代表这门语言的发展趋势。比如我对java比较感兴趣，然后我看了一下前十名，发现大部分都是 android 开发，由此可见android开发的火爆程度。 当然你也可以看到你的排名，会让你有打怪升级的快感。 第二个功能是搜索，输入筛选条件，搜搜程序员！ 1.4 WebIDECoding WebIDE 是 Coding 自主研发的在线集成开发环境 (IDE)。只要你的项目在代码托管平台存放，就可以导入到 WebIDE。之后就可以在线开发。 WebIDE 还提供 WebTerminal 功能，用户可以远程操作Docker容器，自由安装偏好的软件包、方便折腾。 看起来是不是还挺好玩的，如果想把这些都玩转，git 是肯定要好好学的。接下来，我们就看一下 git 的基本原理。 2. Git 原理我们可以现在想一下，如果我们自己来设计，应该怎么设计。 传统的设计方案我们可以简单的分成两块：工作目录，远程仓库。 但是作为一个目标明确的分布式版本控制系统，首先要做的就是添加一个本地仓库。 接着我们选择在工作目录与远程仓库中间加一个缓冲区域，叫做暂存区。 加入暂存区的原因有以下几点： 为了能够实现部分提交 为了不再工作区创建状态文件、会污染工作区。 暂存区记录文件的修改时间等信息，提高文件比较的效率。 至此就我们本地而言有三个重要的区域：工作区、暂存区、本地仓库。 接下来我们想一下本地仓库是如何存放项目历史版本。 2.1 快照 这是项目的三个版本，版本1中有两个文件A和B，然后修改了A，变成了A1，形成了版本2，接着又修改了B变为B1，形成了版本3。 如果我们把项目的每个版本都保存到本地仓库，需要保存至少6个文件，而实际上，只有4个不同的文件，A、A1、B、B1。为了节省存储的空间，我们要像一个方法将同样的文件只需要保存一份。这就引入了Sha-1算法。 可以使用git命令计算文件的 sha-1 值。 12echo 'test content' | git hash-object --stdind670460b4b4aece5915caf5c68d12f560a9fe3e4 SHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。 Sha-1的非常有特点： 由文件内容计算出的hash值 hash值相同，文件内容相同 对于上图中的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id 。同时，它还有一个额外的功能，校验文件完整性。 有了 sha-1 的帮助，我们可以对项目版本的存储方式做一下调整。 2.1.1 数据库中存储的数据内容实际上，现在就与git实际存储的结构一致了。我们可以预览一下实际存储在 .git 下的文件。 我们可以看到，在 objects 目录下，存放了很多文件，他们都使用 sha-1 的前两位创建了文件夹，剩下的38位为文件名。我们先称呼这些文件为 obj 文件。 对于这么多的 obj 文件，就保存了我们代码提交的所有记录。对于这些 obj 文件，其实分为四种类型，分别是 blob、tree、commit、tag。接下来，我们分别来看一下。 blob 首先 A、A1、B、B1 就是 blob 类型的 obj。 blob: 用来存放项目文件的内容，但是不包括文件的路径、名字、格式等其它描述信息。项目的任意文件的任意版本都是以blob的形式存放的。 tree tree 用来表示目录。我们知道项目就是一个目录，目录中有文件、有子目录。因此 tree 中有 blob、子tree，且都是使用 sha-1值引用的。这是与目录对应的。从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，顶层的 tree 对象就代表了当前项目的快照。 commit commit: 表示一次提交，有parent字段，用来引用父提交。指向了一个顶层 tree，表示了项目的快照，还有一些其它的信息，比如上一个提交，committer、author、message 等信息。 2.2 暂存区暂存区是一个文件，路径为： .git/index 它是一个二进制文件，但是我们可以使用命令来查看其中的内容。这里我们关注第二列和第四列就可以了，第四列是文件名，第二列指的是文件的blob。这个blob存放了文件暂存时的内容。 第二列就是sha-1 hash值，相当于内容的外键，指向了实际存储文件内容的blob。第三列是文件的冲突状态，这个后面会讲，第四列是文件的路径名。 我们操作暂存区的场景是这样的，每当编辑好一个或几个文件后，把它加入到暂存区，然后接着修改其他文件，改好后放入暂存区，循环反复。直到修改完毕，最后使用 commit 命令，将暂存区的内容永久保存到本地仓库。 这个过程其实就是构建项目快照的过程，当我们提交时，git 会使用暂存区的这些信息生成tree对象，也就是项目快照，永久保存到数据库中。因此也可以说暂存区是用来构建项目快照的区域。 2.3 文件状态有了工作区、暂存区、本地仓库，就可以来定义文件的状态了。 文件的状态可以分为两类。一类是暂存区与本地仓库比较得出的状态，另一类是工作区与暂存区比较得出的状态。为什么要分成两类的愿意也很简单，因为第一类状态在提交时，会直接写入本地仓库。而第二种则不会。一个文件可以同时拥有两种状态。 比如一个文件可能既有上面的 modified 状态，又有下面 modified 状态，但其实他们表示了不同的状态，git 会使用绿色和红色把这两中 modified 状态区分开来。 2.4 分支接下来，看一个很重要的概念，分支。 分支的目的是让我们可以并行的进行开发。比如我们当前正在开发功能，但是需要修复一个紧急bug，我们不可能在这个项目正在修改的状态下修复 bug，因为这样会引入更多的bug。 有了分支的概念，我们就可以新建一个分支，修复 bug，使新功能与 bug 修复同步进行。 分支的实现其实很简单，我们可以先看一下 .git/HEAD 文件，它保存了当前的分支。 12cat .git/HEAD=&gt;ref: refs/heads/master 其实这个 ref 表示的就是一个分支，它也是一个文件，我们可以继续看一下这个文件的内容： 12cat .git/refs/heads/master=&gt; 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8 可以看到分支存储了一个 object，我们可以使用 cat-file 命令继续查看该 object 的内容。 1234567git cat-file -p 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8=&gt; tree 15f880be0567a8844291459f90e9d0004743c8d9=&gt; parent 3d885a272478d0080f6d22018480b2e83ec2c591=&gt; author Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800=&gt; committer Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800=&gt;=&gt; add branch paramter for rebase 从上面的内容，我们知道了分支指向了一次提交。为什么分支指向一个提交的原因，其实也是git中的分支为什么这么轻量的答案。 因为分支就是指向了一个 commit 的指针，当我们提交新的commit，这个分支的指向只需要跟着更新就可以了，而创建分支仅仅是创建一个指针。 3. 高层命令在 git 中分为两种类型的命令，一种是完成底层工作的工具集，称为底层命令，另一种是对用户更友好的高层命令。一条高层命令，往往是由多条底层命令组成的。 不知道的人可能一听高层感觉很厉害的样子，其实就是指的是那些我们最常使用的git命令。 3.1 Add &amp; Commitadd 和 commit 应该可以说是我们使用频率最高的高层命令了。 123touch README.mdgit add README.mdgit commit -m "add readme” touch 指的是创建一个文件，代表了我们对项目文件内容的修改，add 操作是将修改保存到暂存区，commit 是将暂存区的内容永久保存到本地仓库。 每当将修改的文件加入到暂存区，git 都会根据文件的内容计算出 sha-1，并将内容转换成 blob，写入数据库。然后使用 sha-1 值更新该列表中的文件项。在暂存区的文件列表中，每一个文件名，都会对应一个sha-1值，用于指向文件的实际内容。最后提交的那一刻，git会将这个列表信息转换为项目的快照，也就是 tree 对象。写入数据库，并再构建一个commit对象，写入数据库。然后更新分支指向。 3.2 Conflicts &amp; Merge &amp; Rebase3.2.1 Conflictsgit 中的分支十分轻量，因此我们在使用git的时候会频繁的用到分支。不可不免的需要将新创建的分支合并。 在 git 中合并分支有两种选择：merge 和 rebase。但是，无论哪一种，都有可能产生冲突。因此我们先来看一下冲突的产生。 图上的情况，并不是移动分支指针就能解决问题的，它需要一种合并策略。首先，我们需要明确的是谁和谁的合并，是 2，3 与 4，5，6的合并吗？说到分支，我们总会联想到线，就会认为是线的合并。其实不是的，真实合并的是 3 和 6。因为每一次提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。 我们可以先想一个简单的算法。用来比较3和6。但是我们还需要一个比较的标准，如果只是3和6比较，那么3与6相比，添加了一个文件，也可以说成是6与3比删除了一个文件，这无法确切表示当前的冲突状态。因此我们选取他们的两个分支的分歧点（merge base）作为参考点，进行比较。 比较时，相对于 merge base（提交1）进行比较。 首先把1、3、6中所有的文件做一个列表，然后依次遍历这个列表中的文件。现在我们拿列表中的一个文件进行举例，把在提交1、3、6中的该文件分别称为版本1、版本3、版本6。 版本1、版本3、版本6的 sha-1 值完全相同，这种情况表明没有冲突 版本3或6至少一个与版本1状态相同（指的是sha-1值相同或都不存在），这种情况可以自动合并。比如1中存在一个文件，3对该文件进行修改，而6中删除了这个文件，则以6为准就可以了 版本3或版本6都与版本1的状态不同，情况复杂一些，自动合并策略很难生效，需要手动解决。我们来看一下这种状态的定义。 冲突状态定义： 1 and 3: DELETED_BY_THEM; 1 and 6: DELETED_BY_US; 3 and 6: BOTH_ADDED; 1 and 3 and 6: BOTH_MODIFIED 我们拿第一种情况举例，文件有两种状态 1 和 3，1 表示该文件存在于 commit 1（也就是MERGE_BASE），3 表示该文件在 commit 3 （master 分支）中被修改了，没有 6，也就是该文件在 commit 6（feature 分支）被删除了，总结来说这种状态就是 DELETED_BY_THEM。 可以再看一下第四种情况，文件有三种状态 1、3、6，1 表示 commit 1（MERGE_BASE）中存在，3 表示 commit 3（master 分支）进行了修改，6 表示（feature 分支）也进行了修改，总结来说就是 BOTH_MODIFIED（双方修改）。 遇到不可自动合并冲突时，git会将这些状态写入到暂存区。与我们讨论不同的是，git使用1，2，3标记文件，1表示文件的base版本，2表示当前的分支的版本，3表示要合并分支的版本。 3.2.2 Merge在解决完冲突后，我们可以将修改的内容提交为一个新的提交。这就是 merge。 merge 之后仍可以做出新的提交。 可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用 起来不太方便，比如当我们创建了 pr、mr 或者 将修改补丁发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。 使用 rebase 可以解决这种问题。 3.2.3 Rebase假设我们的分支结构如下： rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新达到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward，即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。 如果我们想要看 rebase 实际上做了什么，有一个方法，那就是用“慢镜头”来看rebase的整个操作过程。rebase 提供了交互式选项(参数 -i)，我们可以针对每一个patch，选择你要进行的操作。 通过这个交互式选项，我们可以”单步调试”rebase操作。 经过测试，其实 rebase 主要在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就可以看得出来。git-rebase-todo 存放了 rebase 将要操作的 commit。而 done 存放正在操作或已经操作完毕的 commit。比如我们这里，git-rebase-todo 存放了 4、5、6，三个提交。 首先 git 将 sha-1 为 4 的 commit 放入 done。表示正在操作 4，然后将 4 以补丁的形式打到 3 上，形成了新的提交 4’。这一步是可能产生冲突的，如果有冲突，需要解决完冲突之后才能继续操作。 接着讲 sha-1 为 5 的提交放入 done 文件，然后将 5 以补丁的形式打到 4’ 上，形成 5’。 再接着将 sha-1 为 6 的提交放入 done 文件，然后将 6 以补丁的形式打到 5’ 上，形成 6’。最后移动分支指针，使其指向最新的提交 6’ 上。这就完成了 rebase 的操作。 我们看一下真实的 rebase 文件。 1234567891011pick e0f56d9 update gitignorepick e370289 add a# Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit 该文件一共有三列，第一列表示要进行的操作，所有可以进行的操作，在下面注释里都列了出来，比如 pick 表示使用该提交，reword 表示使用该提交，但修改其提交的 message，edit 表示使用该提交，但是要对该提交进行一些修改，其它的就不一一说了。 而 done 文件的形式如下，和 git-rebase-todo 是一样的： 12pick e0f56d9 update gitignorepick e370289 add a 从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。 所以使用 rebase 最好不要在公共分支上进行操作。 3.3 Checkout、Revert、Reset3.3.1 Checkout对于 checkout，我们一般不会陌生。因为使用它的频率非常高，经常用来切换分支、或者切换到某一次提交。 这里我们以切换分支为例，从 git 的工作区、暂存区、本地仓库分别来看 checkout 所做的事情。Checkout 前的状态如下： 首先 checkout 找到目标提交（commit），目标提交中的快照也就是 tree 对象就是我们要检出的项目版本。checkout 首先根据tree生成暂存区的内容，再根据 tree 与其包含的 blob 转换成我们的项目文件。然后修改 HEAD 的指向，表示切换分支。 可以看到 checkout 并没有修改提交的历史记录。只是将对应版本的项目内容提取出来。 3.3.2 Revert如果我们想要用一个用一个反向提交恢复项目的某个版本，那就需要 revert 来协助我们完成了。什么是反向提交呢，就是旧版本添加了的内容，要在新版本中删除，旧版本中删除了的内容，要在新版本中添加。这在分支已经推送到远程仓库的情境下非常有用。 Revert 之前： revert 也不会修改历史提交记录，实际的操作相当于是检出目标提交的项目快照到工作区与暂存区，然后用一个新的提交完成版本的“回退”。 Revert 之后： Resetreset 操作与 revert 很像，用来在当前分支进行版本的“回退”，不同的是，reset 是会修改历史提交记录的。 reset 常用的选项有三个，分别是 —soft, —mixed, —hard。他们的作用域依次增大。 我们分别来看。 soft 会仅仅修改分支指向。而不修改工作区与暂存区的内容，我们可以接着做一次提交，形成一个新的 commit。这在我们撤销临时提交的场景下显得比较有用。 使用 reset –soft 前： 使用 reset –soft 后: mixed 比 soft 的作用域多了一个 暂存区。实际上 mixed 选项与 soft 只差了一个 add 操作。 使用 reset –mixed 前： 使用 reset –mixed 后： hard 会作用域又比 mixed 多了一个 工作区。 使用 reset –hard 前： 使用 reset –hard 后： hard 选项会导致工作区内容“丢失”。 在使用 hard 选项时，一定要确保知道自己在做什么，不要在迷糊的时候使用这条选项。如果真的误操作了，也不要慌，因为只要 git 一般不会主动删除本地仓库中的内容，根据你丢失的情况，可以进行找回，比如在丢失后可以使用 git reset –hard ORIG_HEAD 立即恢复，或者使用 reflog 命令查看之前分支的引用。 3.4 stash有时，我们在一个分支上做了一些工作，修改了很多代码，而这时需要切换到另一个分支干点别的事。但又不想将只做了一半的工作提交。在曾经这样做过，将当前的修改做一次提交，message 填写 half of work，然后切换另一个分支去做工作，完成工作后，切换回来使用 reset —soft 或者是 commit amend。 git 为了帮我们解决这种需求，提供了 stash 命令。 stash 将工作区与暂存区中的内容做一个提交，保存起来，然后使用reset hard选项恢复工作区与暂存区内容。我们可以随时使用 stash apply 将修改应用回来。 stash 实现思路将我们的修改提交到本地仓库，使用特殊的分支指针（.git/refs/stash）引用该提交，然后在恢复的时候，将该提交恢复即可。我们可以更进一步，看看 stash 做的提交是什么样的结构。 如图所示，如果我们提供了 —include-untracked 选项，git 会将 untracked 文件做一个提交，但是该提交是一个游离的状态，接着将暂存区的内容做一个提交。最后将工作区的修改做一个提交，并以untracked 的提交、暂存区 的提交、基础提交为父提交。 搞这么复杂，是为了提供更灵活地选项，我们可以选择性的恢复其中的内容。比如恢复 stash 时，可以选择是否重建 index，即与 stash 操作时完全一致的状态。 3.5 bisect最后要讲到一个曾经把我从“火坑”中救出来的功能。 项目发布到线上的项目出现了bug，而经过排查，却找不到问 bug 的源头。我们还有一种方法，那就是先找到上一次好的版本，从上一次到本次之间的所有提交依次尝试，一一排查。直到找到出现问题的那一次提交，然后分析 bug 原因。 git 为我们想到了这样的场景，同样是刚才的思路，但是使用二分法进行查找。这就是 bisect 命令。 使用该命令很简单， 123git bisect startgit bisect bad HEADgit bisect good v4.1 git 会计算中间的一个提交，然后我们进行测试。 根据测试结果，使用 git bisect good or bad 进行标记，git 会自动切换到下一个提交。不断的重复这个步骤，直到找到最初引入 bug 的那一次提交。 我们知道二分法的效率是很高的，2的10次方就已经1024了，因此我们测试一般最多是10次，再多就是11次、12次。其实这就要求我们优化测试的方法，使得简单的操作就能使 bug 重现。如果重新的操作非常简单，简单到我们可以使用脚本就能测试，那就更轻松了，可以使用 git bisect run ./test.sh，一步到位。 如果某一个提交代码跑不起来，可以使用 git bisect skip 跳过当前提交或者使用 visualize 在 git 给出的列表中手动指定一个提交进行测试。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 客户端在 WebIDE 中的实现]]></title>
    <url>%2F2016%2F05%2F03%2Fhow-implement-git-client-in-web-ide%2F</url>
    <content type="text"><![CDATA[Git 客户端在 WebIDE 中的实现上周日做了一个分享，介绍了如何在 WebIDE 中实现 Git 客户端，主要内容包括 Git 原理、JGit 的使用。以下是主要的分享内容。 版本控制管理文档、程序、配置等文件内容变化的的系统。 其实版本控制很想 并不难理解，其实即使不是编程人员对他也不会陌生，比如 windows 的系统还原，mac 的 timemachine。他们在某一时刻，记录下系统的状态或文件的内容，然后在需要的时候可以恢复。 对于程序员来说，他有以下好处： 恢复：当不小心删除了文件、或者改错了文件，可以恢复文件内容 回滚：新版本出现了重大问题，可以回滚到上一正确的状态。 协作：不同开发者根据同一个版本进行开发，形成不同版本可以方便的合并在一起。 常见的版本控制系统常见的版本控制系统有 CVS、SVN、Mercurial、Git 等。 这四个版本控制系统可以根据对网络的要求分成两组，一组是CVS、SVN，一组是 Mercurial、Git。 CVS、SVN：使用中央仓库，开发者需要从中央仓库中取出代码 Mercurial、Git：使用本地仓库，开发者可以本地开发 第一组要求必须连到公司的网络才能办公，而第二组仓库在本地，意味着不用连接到公司的网络，进一步可以说是离线就可以办公。 像Git、Mercurial这样的分布式的版本控制系统变得越来越流行，正在慢慢取代像CVS、SVN“中央式“的版本控制系统。 为什么选择 Git是什么原因让 git 从这么多的版本控制系统中脱颖而出呢？ 本地提交： 这意味着无论你是在家里、还是地铁上都可以离线工作了，不需要连到公司的网络。 轻量级分支： git 的轻量级分支使得你可以快速的切换项目版本。这种特性在某些场景下特别重要，尤其是当我们正在开发过程中，突然发现一个紧急bug需要修复，我们可以快速切换分支，修复bug。 解决冲突方便： 正因为有轻量级的分支，git也鼓励我们使用分支进行开发。但是当我们将分支合并到主干时，不可避免的会出现冲突，而 git 解决冲突的方式对用户非常的友好 有 Github、Coding 这样强大的代码托管平台支持： 在 Github 和 Coding 上有非常多的开源代码，而且这两个平台上的用户非常的活跃，使用 git，有助于接触更多优秀的项目、优秀的开发者，对我们的成长有非常大的帮助。 Git 原理例子一段经典的 git 操作。 123touch README.mdgit add README.mdgit commit -m "add readme" touch READEME.md 可以代表创建、修改文件操作git add README.md 表示将对文件的改动添加到暂存区git commit -m &quot;add readme&quot;表示将改动提交到仓库 这些我们都已经知道了，那么添加到暂存区、提交到仓库具体是什么意思？ 三种状态 git 有三种状态：工作区、暂存区、本地仓库。 add: 工作区 -&gt; 暂存区 commit: 暂存区 -&gt; 本地仓库 工作目录我们是知道的，我们平时编写代码，就是在工作目录中完成的。 暂存区也叫做索引，保存了下次将提交的文件列表。 本地仓库是 Git 用来保存项目的数据的地方。提交代码，意味着将文件内容永久保存到数据库中。 首先看一下本地仓库，项目中的文件在本地仓库中是以快照的形式来保存的。 git 中的快照 每一个 version，都是项目的一次完整快照。而快照中没有修改的文件，Git 使用链接指向之前存储的文件。 这就带来了一个问题，链接是什么？怎么快速的知道文件内容是否发生了改变？git 中的方案是使用 SHA-1。 SHA-112echo 'test content' | git hash-object --stdind670460b4b4aece5915caf5c68d12f560a9fe3e4 特点： 由文件内容计算出的hash值 hash值相同，文件内容相同 作为唯一 id SHA-1将文件中的内容通过算法生成一个 160bit 的报文摘要，即40个十六进制数字。SHA-1的一个重要特征就是几乎可以保证，如果两个文件的SHA-1值是相同的，那么它们确是完全相同的内容。 上面的代码，无论运行几次，得到的 hash 值都是一样的。这个hash值可以看作是该文件的唯一id。 Git 中所有数据在存储前都计算该hash值，然后用该hash值来引用。因此这个 id 除了可以唯一表示任何版本中的文件，还可以表示任何一次提交、任何一次代码的快照。 实际存储在 git 中的数据find .git/objects -type f 我们来看一下实际存储在git中的数据，看起来比较乱，这些数据存放在 .git/objects，然后使用sha-1计算的hash值的前两位作为文件夹的名字，后面的38位作为文件的名字。 在这么多的文件中，其实可以分为4种类型，分别是 blob、commit、tree 和 tag。 将上面的内容经过按照这些类型整理可以得到类似下面的关系（忽略 tag）。 每一个线框表示了一个object，也就是 objects 目录下的一个文件。 每个 object 上面的这个字母与数字组合的字符串，就是object的上一目录名＋文件名，也就是 sha-1 hash 值。 每个 object 的第一行格式是一致的，都由两列组成，第一列表示了 object 的类型，第二列是文件内容的长度。 接下来我们分别看一下每种类型： blob: 用来存放项目文件的内容，项目的任意文件的任意版本都是以 blob 的形式存放的。但是不包括文件的路径、名字、格式等其它描述信息。 tree: 用来表示项目中的目录，我们知道，目录中有文件、有子目录。因此 tree 中有 blob、子 tree。这是与目录的对应。tree 中还包含了文件的路径以及名称。从顶层的 tree 纵览整个树状的结构，叶子结点就是blob，表示文件的内容，非叶子结点表示项目的目录，那么顶层的 tree 对象就代表了当前项目的快照。 commit: 一个commit表示一次提交。里面的 tree 的值指向了项目的快照。还有一些其它的信息，比如 parent，committer、author、message 等信息。tree 看成一个树状的结构，blob 可以作为其中的叶子结点出现。commit 可以看作是一个DAG，有向无环图。因为 commit 可以有一个 parent，也可以有两个或者多个parent。 至此，本地仓库我们就了解完了。接下来看一下暂存区。 暂存区暂存区是工作区与本地仓库之间的一个缓冲，它保存了下次将提交的文件列表信息。它其实是一个文件，路径为： .git/index。由于该文件是一个二进制文件，没办法直接看它的内容，但是可以使用 git 命令查看。 每列的含义依次为，文件权限、文件 blob、文件状态、文件名。 第二列指的是文件的 blob。这个 blob 存放了文件暂存时的内容。 我们操作暂存区的场景是这样的，每当编辑好一个或几个文件后，把它加入到暂存区，然后接着修改其他文件，改好后放入暂存区，循环反复。直到修改完毕，最后使用 commit 命令，将暂存区的内容永久保存到本地仓库。 这个过程其实就是构建项目快照的过程，因此可以说暂存区是用来构建项目快照的区域。 分支接下来看一下分支的概念，首先看一张图： 这张图中的每一个点表示了一个commit。从这张图中我们可以看出的信息有： 从任意一点分歧出来的线都可以叫做分支 分支可以合并 分支的实现在 .git/HEAD 文件中，保存了当前的分支。 12cat .git/HEAD=&gt;ref: refs/heads/master 其实这个 ref 表示的就是一个分支，它也是一个文件，我们可以继续看一下这个文件的内容： 12cat .git/refs/heads/master=&gt; 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8 可以看到分支存储了一个 object，我们可以使用 cat-file 命令继续查看该 object 的内容。 1234567git cat-file -p 2b388d2c1c20998b6233ff47596b0c87ed3ed8f8=&gt; tree 15f880be0567a8844291459f90e9d0004743c8d9=&gt; parent 3d885a272478d0080f6d22018480b2e83ec2c591=&gt; author Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800=&gt; committer Hehe Tan &lt;xiayule148@gmail.com&gt; 1460971725 +0800=&gt;=&gt; add branch paramter for rebase 从上面的内容，我们知道了分支指向了一次提交。为什么分支指向一个提交的原因，其实也是git中的分支为什么这么轻量的答案。 因为分支就是指向了一个 commit 的指针，当我们提交新的commit，这个分支的指向只需要跟着更新就可以了，而创建分支仅仅是创建一个指针。 至此git的原理就讲完了，接下来看一下 JGit。 JGitJGit 是一个用 Java 实现的比较健全的 git 实现，Eclipse IDE 中的 git 插件 Egit，就是基于 JGit 开发的。同 git 一样，它提供了底层命令和高层命令。 高层命令的入口是 Git 类。高层命令好理解，我们使用 git 的客户端绝大多数命令都是高层命令。 比如 add、commit、checkout 等都是高层命令，他们提供了友好的交互，往往一条命令就能完成你所想要的效果。 底层命令的入口是 Repository 类。底层命令不同于高层命令，它们直接作用域 仓库（Repository）。比如 AbstractTreeIterator，就是用来遍历 Tree 结构的，DirCache 是用来操作暂存区的，RevWalk 是用来遍历 commit 的，ObjectInsert 是用来生成 obj的，ObjectLoader 是用来加载 object。 一条高层命令往往是由多条底层命令组成的。 Repository(仓库)作为一切的开始，你需要一个 Repository。 1234Repository repository = new FileRepositoryBuilder() .setGitDir(new File("/home/tan/GitTest/.git")) .readEnvironment() .build(); 使用时只需要将仓库的路径传进来就可以了，它会自动读取一些必要的环境变量。 ObjectInserterObjectInserter用来将数据插入到git数据库中，也就是 objects 目录下。插入的类型为我们刚才提到的四种，分别是 Blob、Tree、Commit、Tag。 12345try (ObjectInserter inserter = repo.newObjectInserter()) &#123; ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, new String("test").getBytes()); inserter.flush();&#125; 第二个参数表示要插入的数据，该数据会自动使用 zlib 压缩。 TreeWalk用来遍历目录结构，可以为工作区、暂存区或项目快照（版本库）。 123456789101112131415try (TreeWalk treeWalk = new TreeWalk(repo)) &#123; treeWalk.setRecursive(true); treeWalk.addTree(new FileTreeIterator(repo)); treeWalk.addTree(new DirCacheIterator(repo.readDirCache())); while (treeWalk.next()) &#123; AbstractTreeIterator treeIterator = treeWalk.getTree(0, AbstractTreeIterator.class); DirCacheIterator dirCacheIterator = treeWalk.getTree(1, DirCacheIterator.class); &#125;&#125; TreeWalk 是用来遍历树这种结构的，它比较厉害的一点是可以同时遍历多棵树，遍历多课树的思路为将文件列表做一个合并，然后遍历这个列表，没有的调用 getTree 会返回 null 值。 其实 git status 就是这种原理来做的: changed： 在版本库、idnex 中都存在，内容不同 removed： 在版本库存在，在 index 不存在 added：在 index 存在，在版本库不存在 untracked：不在版本库和 index，只在工作目录中存在 modified：在 index，在工作区，且文件内容不同 missing：在 index 存在，在工作区不存在 RevWalkRevWalk 用来遍历 Commit。 123456789try (RevWalk revWalk = new RevWalk(repository)) &#123; revWalk.markStart(one); revWalk.markStart(two); revWalk.setRevFilter(RevFilter.MERGE_BASE); RevCommit base = revWalk.next();&#125; 我们这个例子，标记了两个 commit，我们设置的 filter 是 MERGE_BASE, 它会自动查找这两个 commit 所在分支的 MERGE_BASE。其中 MERGE_BASE 可以看作是分支的分岔点，合并的时候 MERGE_BASE 会作为参照。 使用底层命令高层命令其实是由多条底层命令组成的，比如我们最常使用的 add、commit： add 使用 ObjectInserter 将文件内容写入 objects (blob)，得到 blob id 使用 DirCache 将 blob id 写入暂存区 commit 使用 DirCache 将 index 生成 tree 使用 ObjectInserter 将 tree 写入仓库(tree)，得到 tree 的 id 构建 commit，写入 tree id 以及设置其 parent、message 等其它信息 利用 ObjectInserter 将 commit 写入 objects (commit)，得到 commit id 将 commit id 写入当前的 branch，使得 branch 指向最新的 commit 高层命令上面的复杂操作，可以简单的用底层命令替代。 12git.add().addFilepattern("README").call();git.commit().setMessage("add readme").call(); 高级操作的局限高层命令使用起来方便，但是它所提供的功能有限。这里我们拿 merge 举例。 使用 JGit Merge api使用 JGit 提供的接口进行 merge 十分的方便，只需要指定要合并的 branch 就可以了。 123MergeCommand merge = git.merge();merge.include(branch);MergeResult result = merge.call(); 但是 merge 之后呢，文件冲突了怎么办，怎么解决冲突呢？实际上除了 merge，stash、rebase 等等操作也都会产生冲突。也就是说 git 冲突文件的处理是客户端的重要功能之一。 遗憾的是 jgit 并没有提供解决冲突的方案，所以这就需要我们自己来解决这个问题。 resolve conflicts:一种比较理想的解决冲突的方案是，将冲突的文件根据本地修改、基础版本、要合并分支的修改分成三栏。 通过这样的方式，我们可以直观的对照冲突的内容，并且可以方便的选取或者要抛弃修改。 可选方案 计算 merge base 第一个就是计算这两个分支的 MERGE_BASE。这样我们获得了三个 commit，每个 commit 都都纪录了提交时的文件快照。而我们只要将冲突文件的内容从快照中取出来就好了。但是这个方案有个缺点，那就是我们只有在合并的那一瞬间才能知道要合并的分支，之后想要知道只能去 .git 下面的 MERGE_HEAD 去查，而且其它方式比如 stash、rebase 等操作引起的冲突是不会生成该文件的。 使用暂存区的信息 想想我们 当我们有合并冲突状态时，使用 git status，会列出冲突文件，以及冲突的类型，比如 “双方修改”、“由我们删除”，“双方添加”等这样的字眼，git 如果获得这些信息的呢？ 如果存在冲突文件，我们查看暂存区，可以看到类似下面的内容： 1234git ls-files --stage100644 6e9f0da13f19b444ec3a9c3d6e795ad35c0554a2 1 Readme100644 29d460866c44ad72cc08ef4983fc6ebd48053bab 2 Readme100644 12892f544e81ef2170034392f63c7fc5e6c6ccd9 3 Readme 原来暂存区中有四种状态用于标示文件： * **0:** standard stage * **1:** base tree revision * **2:** first tree revision (usually called &quot;ours&quot;) * **3:** second tree revision (usually called &quot;theirs&quot;) 接下来我们专门看一下这4种状态是如何表示冲突状态的。 文件冲突的状态：假设当前我们处于 master 分支，要合并的分支为 test，开发历史如下图： 现在假设合并过程中有个文件（Readme）发生了冲突，我们查询暂存区该文件的状态（可以有多个）： 1 and 2: DELETED_BY_THEM; 1 and 3: DELETED_BY_US; 2 and 3: BOTH_ADDED; 1 and 2 and 3: BOTH_MODIFIED 我们拿第一种情况举例，文件（Readme）有两种状态 1 和 2，1 表示该文件存在于 commit 1（也就是MERGE_BASE），2 表示该文件在 commit 2 （master 分支）中被修改了，没有状态 3，也就是该文件在 commit 3（test分支）被删除了，总结来说这种状态就是 DELETED_BY_THEM。 可以再看一下第四种情况，文件（Readme）有三种状态 1、2、3，1 表示 commit 1（MERGE_BASE）中存在，2 表示 commit 2（master 分支）进行了修改，3 表示（test 分支）也就行了修改，总结来说就是 BOTH_MODIFIED（双方修改）。 获取冲突文件的三个版本知道了冲突文件的状态，就能在暂存区获得冲突文件的三个版本了。代码如下： 123456789101112131415161718192021DirCache dirCache = repository.readDirCache();// 在暂存区中，所有文件是按照字母顺序排列的，因此文件的不同状态是连着的int eIdx = dirCache.findEntry(path);// nextEntry 会自动调过文件名相同的文件，找到下一个文件。int lastIdx = dirCache.nextEntry(eIdx);// 在 [eIdx, lastIdx) 区间的也就是文件的冲突的不同版本for (int i=0; i&lt;lastIdx - eIdx; i++) &#123; DirCacheEntry entry = dirCache.getEntry(eIdx + i); // 如果是 MERGE_BASE if (entry.getStage() == DirCacheEntry.STAGE_1) readBlobContent(entry.getObjectId()); // 如果是 当前分支 else if (entry.getStage() == DirCacheEntry.STAGE_2) readBlobContent(entry.getObjectId()); // 如果是 要合并的分支 else if (entry.getStage() == DirCacheEntry.STAGE_3) readBlobContent(entry.getObjectId());&#125; 至此我们得到了解决合并冲突的一个方案。 Thanks]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 项目优化实战]]></title>
    <url>%2F2016%2F03%2F27%2Fhow-to-optimize%2F</url>
    <content type="text"><![CDATA[1 Visual VM项目中的某一个接口，在某一场景下（数据量大），性能让人难以忍受。 那么如何有什么工具可以定位引发性能问题的代码呢？其实有很多，这里我们使用 Visual VM。 Visual VM 是一款用来分析 Java 应用的图形工具，能够对 Java 应用程序做性能分析和调优。如果你使用的 java 7 或者 java 8，那么可以直接在 JDK 的 bin 目录找到该工具，名称为 jvisualvm。当然也可以在官网上自行下载。 使用 Visual VM 分析某个接口的性能的方法如下： 结果显示如下: 通过上图，我们可以看到比较耗时的方法为 resolveBytePosition 和 rest，getFile 和 currentUser 是网络请求，暂不考虑。 2 优化一2.1 背景首先拿 resolveBytePosition 方法开刀。为了能更容易的解释 resolveBytePosition 的用途，举个例子。 给定一个字符串 chars 与该字符串的 UTF-8 二进制数组(空格用来隔开字符数据，实际并不存在): chars = &quot;just一个test&quot;; bytes = &quot;6A 75 73 74 E4B880 E4B8AA 74 65 73 74&quot;; resolveBytePosition 用来解决给定一个 bytes 的偏移 bytePos 计算 chars 中的偏移 charPos 的问题。比如: bytePos = 0 (6A) 对应 charPos = 0 (j) bytePos = 1 (75) 对应 charPos = 1 (u) 如果使用 array[start:] 表示从下标 start 开始截取数组元素至末尾组成的新数组，那么则有： bytes[bytePos:] = chars[charPos:] 举例: bytes[0:] = chars[0:] bytes[1:] = chars[1:] bytes[10:] = chars[6:] 2.2 原实现明白了 resolveBytePosition 的作用，看一下它的实现 123public int resolveBytePosition(byte[] bytes, int bytePos) &#123; return new String(slice(bytes, 0, bytePos)).length();&#125; 该解法简单粗暴，能够准确的计算出结果，但是缺点显而易见，频繁的构建字符串，对性能造成了极大的影响。通过 Visual VM 可以证实我们的推论，通过点击快照，查看更详细的方法调用耗时。 2.3 剖析为了更方便的剖析问题，我们绘制如下表格，用来展示每一个字符的 UTF-8 以及 Unicode 的二进制数据： j u s t 一 个 t e s t UTF-8 6A 75 73 74 E4B880 E4B8AA 74 65 73 74 Unicode 6A 75 73 74 4E00 4E2A 74 65 73 74 接着我们将字节数据转换为字节长度： j u s t 一 个 t e s t UTF-8 1 1 1 1 3 3 1 1 1 1 Unicode 1 1 1 1 2 2 1 1 1 1 Java中的使用 char 来表示Unicode，char 的长度为 2 个字节，因此一个 char 足以表示示例中的任何一个字符。 我们使用一个单元格表示一个byte（UTF-8）或一个char（Unicode），并对单元格编号，得到下表： &nbsp;just一个testbytes012345678910111213chars0123456789 可以得出下面对应关系 bytes[0:] = chars[0:] bytes[1:] = chars[1:] bytes[2:] = chars[2:] bytes[3:] = chars[3:] bytes[4:] = chars[4:] bytes[7:] = chars[5:] bytes[10:] = chars[6:] ... ... 2.3 方案进行到这一步，高效的算法已经呼之欲出了。算法如下： 把字符 UTF-8 数据的二进制长度不为 1 的称为特征点。除特征点外，每个字符都是一个字节长度。记下所有特征点的对应关系，对于给定的 bytePos，都可以根据公式计算得到 charPos。 公式为: charPos = bytePos - preBytePos + preCharPos 举例： 则本实例中有两个特征点 一、个，记作： bytes[6:] = chars[4:] bytes[9:] = chars[5:] 如果给定 bytePos 10, 首先找到前一个特征点的对应关系 9（preBytePos） -&gt; 5（preCharPos), 根据公式得出 (10 - 9) + 5 = 6。 2.4 核心代码该算法还有一个比较关键的问题要解决，即高效的计算一个 char 的字节长度。计算 char 的字节长度的算法参考了 StackOverflow。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 计算特征点private int[][] calcSpecialPos(String str) &#123; ArrayList&lt;int[]&gt; specialPos = new ArrayList&lt;&gt;() specialPos.add(new int[] &#123;0, 0&#125;); int lastCharPost = 0; int lastBytePos = 0; Charset utf8 = Charset.forName("UTF-8"); CharsetEncoder encoder = utf8.newEncoder(); CharBuffer input = CharBuffer.wrap(str.toCharArray()); ByteBuffer output = ByteBuffer.allocate(10); int limit = input.limit(); while(input.position() &lt; limit) &#123; output.clear(); input.mark(); input.limit(Math.min(input.position() + 2, input.capacity())); if (Character.isHighSurrogate(input.get()) &amp;&amp; !Character.isLowSurrogate(input.get())) &#123; //Malformed surrogate pair lastCharPost++; &#125; input.limit(input.position()); input.reset(); encoder.encode(input, output, false); int encodedLen = output.position(); lastCharPost++; lastBytePos += encodedLen; if (encodedLen != 1) &#123; // 特征点 specialPos.add(new int[]&#123;lastBytePos, lastCharPost&#125;); &#125; &#125; return toArray(specialPos);&#125;// 根据特征点，计算 bytePos 对应的 charPosprivate int calcPos(int[][] specialPos, int bytePos) &#123; // 如果只有一个元素 &#123;0, 0)，说明没有特征值 if (specialPos.length == 1) return bytePos; int pos = Arrays.binarySearch(specialPos, new int[] &#123;bytePos, 0&#125;, (int[] a, int[] b) -&gt; Integer.compare(a[0], b[0])); if (pos &gt;= 0) &#123; return specialPos[pos][1]; &#125; else &#123; // if binary search not fonund, will return (-(insertion point) - 1), // so here -2 is mean -1 to get insertpoint and then -1 to get previous specialPos int[] preSpecialPos = specialPos[-pos-2]; return bytePos - preSpecialPos[0] + preSpecialPos[1]; &#125;&#125; 3 优化二3.1 背景接下来解决第二个函数 rest。该函数的功能是得到 JsonArray（gson） 的除第一个元素外的所有元素。 由于 rest 是在一个递归函数中被调用且递归栈很深，因此如果 rest 实现的不够高效，其影响会被成倍放大。 3.2 原实现123456789private JsonArray rest(JsonArray arr) &#123; JsonArray result = new JsonArray(); if (arr.size() &gt; 1) &#123; for (int i = 1; i &lt; arr.size(); i++) &#123; result.add(arr.get(i)); &#125; &#125; return result;&#125; 3.3 剖析通过调试发现 JsonArray 中存储了相当大的数据，对于频繁调用的场景，每次都对其重新构建明显不是一个明智的选择。通过查看返回的 JsonArray 使用情况，我们得到了另一条线索：仅仅使用里面的数据，而不涉及修改。 考虑到 JsonArray 被实现成 final，最后方案确定为实现一个针对 rest 这种需求定制的代理类。 3.4 方案 &amp; 代码代理类 JsonArrayWrapper 分别对 first、rest、foreach 等功能进行了实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class JsonArrayWrapper implements Iterable&lt;JsonElement&gt; &#123; private JsonArray jsonArray; private int mark; public JsonArrayWrapper() &#123; this.jsonArray = new JsonArray(); this.mark = 0; &#125; public JsonArrayWrapper(JsonArray jsonArray) &#123; this.jsonArray= jsonArray; this.mark = 0; &#125; public JsonArrayWrapper(JsonArray jsonArray, int mark) &#123; this.jsonArray = jsonArray; this.mark = mark; &#125; public JsonObject first() &#123; return jsonArray.get(mark).getAsJsonObject(); &#125; public JsonArrayWrapper rest() &#123; return new JsonArrayWrapper(jsonArray, mark+1); &#125; public int size() &#123; return jsonArray.size() - mark; &#125; public JsonElement get(int n) &#123; return jsonArray.get(mark + n); &#125; public void add(JsonElement jsonElement) &#123; jsonArray.add(jsonElement); &#125; public void addAll(JsonArrayWrapper jsonArrayWrapper) &#123; jsonArrayWrapper.forEach(this.jsonArray::add); &#125; @Override public Iterator&lt;JsonElement&gt; iterator() &#123; JsonArray jsonarray = new JsonArray(); this.forEach(e -&gt; jsonarray.add(e)); return jsonarray.iterator(); &#125; @Override public void forEach(Consumer&lt;? super JsonElement&gt; action) &#123; for (int i=mark; i&lt;jsonArray.size(); i++) &#123; action.accept(jsonArray.get(i)); &#125; &#125;&#125; 4 成果经过这两个主要的优化，就解决了代码中的性能问题，成果如下图所示：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>optimize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 与 Unicode]]></title>
    <url>%2F2016%2F03%2F15%2Fjava-and-unicode%2F</url>
    <content type="text"><![CDATA[优化项目时，遇到了 Unicode 一些相关的问题，为此，需要了解 Java 中是如何支持 Unicode。以下是整理的笔记。 一、Unicode 是什么？Unicode 简单说来就是对世界上大部分的文字系统进行了整理，然后为他们编号。 目前最新的版本是 2015 年 6 月 17 日公布的 8.0.0，收录了 120737 个字符。 Unicode 将这些字符分成 17 组编排，每组称为平面（Plane），每平面拥有 65536（即 $$2^{16}$$）个编号，每个编号称为码点。 U+0000 至 U+FFFF 构成的平面称为基本多文种平面，英文名称 Basic Multilingual Plane，简称 BMP。最常见的字符通常都在该平面内。剩余从 U+10000 至 U+10FFFF 的 16 个平面称为辅助平面。 在表示一个 Unicode 字符时，通常会用 “U+” 然后紧接着一组十六进制的数字来表示这一个字符。 U+4E2D = 中U+1F466 = 使用过 emoji 的可能知道，emoji 在不同的平台（比如苹果、安卓）上的表现形式是不同的 上面的都可以使用 U+1F601 表示，这也说明了 Unicode 的另一个特点，为每一个字符而非字形定义唯一的代码（码点）。 二、UTF-32、UTF-16、UTF-8前面提到的 U+4E2D，最简单的存储方式是使用 32 位二进制，即 4 个字节来表示, 称为 UTF-32（或 UCS-4）。 假设我们现在使用 UTF-32 对字符进行存储、传输，那么像 A（U+0041）这样的原本仅需要一个字节来表示的字符，现在需要 4 个字节，这就造成了存储空间浪费、传输效率降低。 实际上我们绝大部分使用的是基本多文众平面中的字符，也就是说，我们使用的绝大部分字符 1-2 个字节就可以表示了。 除基本平面可以用 2 个字节表示外，其它的平面都至少需要 3 个字节，因为它们的范围是 U+10000 至 U+10FFFF 如果以 16 位长的码元（即 2 个字节为单位）表示基本平面内的字符，一个 16 位的码元就够了，但是要表示辅助平面内的字符，需要一对，称为代理对（surrogate pair）。由于长度不固定，因此这是一个变长表示。 平面 编码范围 字节数量 基本多文种平面 U+0000—U+FFFF 2 辅助平面 U+10000—U+10FFFF 4 如果用 8 位长的码元（即 1 个字节为单位），需要 1 到 4 个字节，称为 UTF-8。这也是一个变长表示。 编码范围 字节数量 0x0000 - 0x007F 1 0x0080 - 0x07FF 2 0x0800 - 0xFFFF 3 0x010000 - 0x10FFFF 4 三、Java 对 Unicode 的支持Java 使用的是 UTF-16。char 类型的长度为 2 个字节，就代表一个长度为 16 的码元。因此对于基本平面内的字符，一个 char 就可以表示一个字符。 12char ch = '中';Integer.toHexString(ch); ==&gt; 4e2d 这与 “中” 的码点 U+4E2D 是一致的。 Java 提供了将码点转换为 UTF-16 形式(即用 char 来表示)的函数， java.lang.Character.toChars，该函数声明如下: 1public static char[] toChars(int codePoint); 使用该函数，我们看到辅助平面内的字符需要用两个char来表示： 12Character.toChars(0x4E2D).length ==&gt; 1Character.toChars(0x1F466).length ==&gt; 2 因此，原来我们统计字符个数的方法就不正确了。 1new String(Character.toChars(0x1F466)).length() ==&gt; 2 这时，可以使用 12String s = new String(Character.toChars(0x1F466));s.codePointCount(0, s.length()) ==&gt; 1 Java 中关于使用 Character.toCodePoint 计算码点，计算方法为: 1((high &lt;&lt; 10) + low) + (0x010000 - ('\uD800' &lt;&lt; 10) - '\uDC00') 还有其他的一些处理码点的函数（部分）： 12345678910String.codePointAt 返回指定位置的码点String.offsetByCodePoints 从 index 开始，接下来第n个代码点的下标String.Character.codePointBefore 返回指定位置处前面的一个码点Character.isBmpCodePoint 判断一个码点是否为 BMPCharacter.toCodePoint 给定一个代理对，转换为码点Character.isSupplementaryCodePoint 判断代码点是否为辅助平面，即是否由两个 char 表示Character.charCount 判断给定码点需要几个char表示Character.isSurrogatePair 判断两个 char 是否为一个代理对Character.isHighSurrogate 判断 char 是否为代理对中的高位Character.isLowSurrogate 判断 char 是否为代理对中的低位 四、参考https://zh.wikipedia.org/wiki/Unicodehttps://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84http://apps.timwhitlock.info/emoji/tables/unicodehttp://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.htmlhttp://www.ruanyifeng.com/blog/2014/12/unicode.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Oauth2 入门]]></title>
    <url>%2F2016%2F02%2F28%2Fspring-oauth2-introduce%2F</url>
    <content type="text"><![CDATA[如果我们的客户端需要对用户 Github 进行一些操作，比如读取用户项目列表、上传 SSH Key 等，需要先获得 Gtihub 的授权。而 Github 使用 Oauth 2 进行授权。 本篇博客要介绍的 Spring Oauth2 是 Oauth 2.0 的实现，它简化了大部分的操作, 比如获得 access token、刷新 access token 的过程，使得通过简单配置，就可以轻松接入第三方的 Oauth 2.0 服务。 如果不了解 Oauth 2 的原理，推荐阅读阮一峰的文章。 一、创建 Gtihub 应用了解完 Oauth2 原理，我们通过一个 demo，了解 spring oauth2 使用方法。 登录 Github 后，依次选择 Settings -&gt; OAuth applications -&gt; Developer applications -&gt; Register new application, 然后配置应用的信息, 依次填写 Application Name、Homepage URL、Application description、Authorization callback URL后，选择 Regiser application。 其中 Authorization callback URL 需要特别注意下，当我们请求 Github 授权时，有一个可选参数 redirect_uri，该参数指定了 Github 完成授权后重定向的网址。如果省略该参数，Github 会默认重定向到 Authorization callback URL。除此之外 Authorization callback URL 对 redirect_uri 也有一定的限制作用，即 redirect_uri 只能是 Authorization callback URL 的子路径。 创建完 Github 应用，我们就得到了 Github 分发的 Client Id 与 Client Secret。 二、为项目添加 maven 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.0.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; 三、开启注解配置12345@Configuration@EnableOAuth2Clientpublic class OAuthConfig &#123;&#125; 该注解提供将会做两件事： 注册一个 Filter（oauth2ClientContextFilter） 创建一个作用域为 request、类型为 AccessTokenRequest 的 bean。 三、配置客户端信息OAuth 2.0 有四种授权方式。分别为： 授权码模式（authorization code）简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials） spring 提供了 4 种 bean，依次与这四种授权方式对应，用来设定每种方式的配置信息。 这 4 个 bean 依次为：AuthorizationCodeResourceDetails、ImplicitResourceDetails、ImplicitResourceDetails、ClientCredentialsResourceDetails。 我们使用授权码模式配置 github 的 id、secret、申请认证地址、申请令牌地址、scope等信息，可以这么写： 1234567891011@Beanpublic OAuth2ProtectedResourceDetails github() &#123; AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); details.setId("github"); details.setClientId("your client id"); details.setClientSecret("your client secret"); details.setAccessTokenUri("https://github.com/login/oauth/access_token"); details.setUserAuthorizationUri("https://github.com/login/oauth/authorize"); details.setScope(Arrays.asList("repo", "user:email", "write:public_key", "read:public_key")); return details;&#125; 四、配置 Oauth2Clientcontext12345678@Resource(name = "accessTokenRequest")private AccessTokenRequest accessTokenRequest;@Bean@Scope(value = "session", proxyMode = INTERFACES)public OAuth2ClientContext githubOauth2ClientContext() &#123; return new DefaultOAuth2ClientContext(accessTokenRequest);&#125; accessTokenRequest 的配置信息在 OAuth2ClientConfiguration 中, accessTokenRequest 的作用域是 request，即每一次 HTTP 请求都会产生一个新的 accessTokenRequest。 这里的 @Scope(value = &quot;session&quot;, proxyMode = INTERFACES)， session 的意思是该 bean 的作用域为 session 级别，而 proxyMode = INTERFACES 保证了，即使该类被比作用域大于 session 的 bean 所持有，仍能保证在不同的 session，会构造不同的 OAuth2ClientContext。 五、配置 OAuth2RestTemplate1234@Beanpublic OAuth2RestOperations githubRestTemplate(@Qualifier("githubOauth2ClientContext") OAuth2ClientContext clientContext) &#123; return new OAuth2RestTemplate(github(), clientContext);&#125; 通常，我们需要接入多个 oauth2 服务，因此会有多个 clientContext，这里我们使用 Qualifier 注解按照 bean 的名称注入。 如果我们确认只接入一个 oauth2 服务，那么就可以完全省略第四步，然后将第五步改为下面的代码： 1234@Beanpublic OAuth2RestOperations githubRestTemplate(OAuth2ClientContext clientContext) &#123; return new OAuth2RestTemplate(github(), clientContext);&#125; 可以直接注入 clientContext 的原因是 OAuth2ClientConfiguration 类已经默认为我们提供了。 六、配置 OAuth2RestTemplate得到了 OAuth2RestTemplate，我们只需要使用 OAuth2RestTemplate 请求对应的服务就可以了。 比如要获取用户 github 所有的项目： 1JsonObject repos = githubRestTemplate.getForObject("https://api.github.com/user/repos", JsonObject.class); 源码demo 中包含了 Github 与 Bbitbucket 的 Oauth2.0 授权以及 Bitbucket 的 Oauth 1.0 授权配置。 https://github.com/tanhe123/SpringOAuthSeample 参考https://github.com/spring-projects/spring-security-oauth 中的 sampleshttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.htmlhttps://developer.github.com/v3/http://projects.spring.io/spring-security-oauth/docs/oauth2.htmlhttp://www.oschina.net/translate/oauth-2-developers-guide]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手编写 Mockito]]></title>
    <url>%2F2016%2F01%2F10%2Fhow-implement-mockito%2F</url>
    <content type="text"><![CDATA[在 WebIDE 团队内部是要求写单元测试的！ 这是我第一次接触Mockito。 初次使用 Mockito，能够感受到它的神奇，尤其是这样的语法： 1when(cal.add(0, 1)).thenReturn(1); Mockito 会把它理解成，当 cal 调用 add 方法且参数为 0 和 1 时，则返回 1。 我们知道，java 中的程序调用是以栈的形式实现的，对于 when 方法，add 方法的调用对它是不可见的。when 能接收到的，只有 add 的返回值。 那么 Mockito 是如何实现的呢？我们知道，Mock 使用了代理模式。我们操作的 cal，实际上是继承了 Calculate 的代理类的实例，我们把它称为 proxy 对象。因此对于 cal 的所有操作，都会先经过 proxy 对象。 Mocktio 就是通过这种方式，拦截到了 cal 的所有操作。只要在调用 cal 的方法时，将该方法存放起来，然后在调用 thenReturn 为其设置返回值就可以了。 光说不练假把式既然知道了原理，那我们也来尝试着实现一个简单的 Mockito。顺便加深下对代理模式的理解。 该 Mockito 需要支持的特性有 mock、stub、spy。 第一步： 实现 mock既然要实现 mock，我们要知道，一个对象被 mock 后，有什么特征。 在单元测试中，我们要测试的模块可能依赖一些不易构造或比较复杂的对象，因此，mock 要支持通过接口、具体类构造 mock 对象。被 mock 的对象只是“假装”调用了该方法，然后“应付”的返回“空值”就可以了。 我们通过 cglib 来实现，实现代码很简单。 12345678910111213public static &lt;T&gt; T mock(Class&lt;T&gt; clazz) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(new MockInterceptor()); return (T) enhancer.create();&#125;private static class MockInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return null; &#125;&#125; 测试用例我们可以这么写 12Calculate cal = mock(Calculate.class);Assert.assertEquals(0, cal.add(0, 1)); 第二步，实现 stub接下来我们来实现 stub。stub 一个方法，其实就是指定该方法在具体参数下的返回值。而且该返回值无论经过多少次调用都是不变的，除非再次 stub 该方法，用新的返回值将原来的替换掉。 首先，我们定义一个类，用来表示对一个函数的调用。 1234567891011public class Invocation &#123; private final Object mock; private final Method method; private final Object[] arguments; private final MethodProxy proxy; // 省略其它不重要代码...&#125; 接下来，在 MockInterceptor 类中，需要做两个操作。 为了设置方法的返回值，需要存放对方法的引用（lastInvocation） 调用方法时，检查是否已经设置了该方法的返回值（results）。如果设置了，则返回该值。 实现代码如下： 1234567891011121314151617181920212223242526private static class MockInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; Invocation invocation = new Invocation(proxy, method, args, proxy); lastInvocation = invocation; if (results.containsKey(invocation)) &#123; return results.get(invocation); &#125; return null; &#125;&#125;public static &lt;T&gt; When&lt;T&gt; when(T o) &#123; return new When&lt;T&gt;();&#125;public static class When&lt;T&gt; &#123; public void thenReturn(T retObj) &#123; results.put(lastInvocation, retObj); &#125;&#125; 可以通过下面测试下效果： 123Calculate cal = mock(Calculate.class);when(cal.add(0, 1)).thenReturn(1);Assert.assertEquals(1, cal.add(0, 1)); 第三步，实现 spy如果说 mock 的处理是返回“空值”，那么 spy 的处理就是通过代理对象调用真实方法了。 我们使用 cglib 提供的方法，使得 spy 生成的代理类，默认调用真实方法。 123456789public Object callRealMethod() &#123; try &#123; return this.proxy.invokeSuper(obj, arguments); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return null;&#125; 就这么简单，spy就实现了，可以使用下面的代码测试 1234Calculate cal = spy(Calculate.class);Assert.assertEquals(3, cal.add(1, 2));when(cal.add(1, 2)).thenReturn(0);Assert.assertEquals(0, cal.add(1, 2)); 备注：限于篇幅，只贴出关键代码，可以查看源代码了解更多细节 源代码附上示例代码: https://coding.net/u/tanhe123/p/MockitoSamples]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>mockito</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究 Spring Security 缓存请求]]></title>
    <url>%2F2015%2F12%2F07%2Fhow-spring-security-cache-request%2F</url>
    <content type="text"><![CDATA[为什么要缓存?为了更好的描述问题，我们拿使用表单认证的网站举例，简化后的认证过程分为7步: 用户访问网站，打开了一个链接(origin url)。 请求发送给服务器，服务器判断用户请求了受保护的资源。 由于用户没有登录，服务器重定向到登录页面 填写表单，点击登录 浏览器将用户名密码以表单形式发送给服务器 服务器验证用户名密码。成功，进入到下一步。否则要求用户重新认证（第三步） 服务器对用户拥有的权限（角色）判定: 有权限，重定向到 origin url; 权限不足，返回状态码 403(“forbidden”). 从第3步，我们可以知道，用户的请求被中断了。 用户登录成功后（第7步），会被重定向到 origin url，spring security 通过使用缓存的 request，使得被中断的请求能够继续执行。 使用缓存用户登录成功后，页面重定向到 origin url。浏览器发出的请求优先被拦截器 RequestCacheAwareFilter 拦截，RequestCacheAwareFilter 通过其持有的 RequestCache 对象实现 request 的恢复。 123456789public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // request匹配，则取出，该操作同时会将缓存的request从session中删除 HttpServletRequest wrappedSavedRequest = requestCache.getMatchingRequest((HttpServletRequest) request, (HttpServletResponse) response); // 优先使用缓存的request chain.doFilter(wrappedSavedRequest == null ? request : wrappedSavedRequest, response);&#125; 何时缓存首先，我们需要了解下 RequestCache 以及 ExceptionTranslationFilter。 RequestCacheRequestCache 接口声明了缓存与恢复操作。默认实现类是 HttpSessionRequestCache。HttpSessionRequestCache 的实现比较简单，这里只列出接口的声明: 123456789101112131415public interface RequestCache &#123; // 将request缓存到session中 void saveRequest(HttpServletRequest request, HttpServletResponse response); // 从session中取request SavedRequest getRequest(HttpServletRequest request, HttpServletResponse response); // 获得与当前request匹配的缓存，并将匹配的request从session中删除 HttpServletRequest getMatchingRequest(HttpServletRequest request, HttpServletResponse response); // 删除缓存的request void removeRequest(HttpServletRequest request, HttpServletResponse response);&#125; ExceptionTranslationFilterExceptionTranslationFilter 是 Spring Security 的核心 filter 之一，用来处理 AuthenticationException 和 AccessDeniedException 两种异常。 在我们的例子中，AuthenticationException 指的是未登录状态下访问受保护资源，AccessDeniedException 指的是登陆了但是由于权限不足(比如普通用户访问管理员界面）。 ExceptionTranslationFilter 持有两个处理类，分别是 AuthenticationEntryPoint 和 AccessDeniedHandler。 ExceptionTranslationFilter 对异常的处理是通过这两个处理类实现的，处理规则很简单： 规则1: 如果异常是 AuthenticationException，使用 AuthenticationEntryPoint 处理规则2: 如果异常是 AccessDeniedException 且用户是匿名用户，使用 AuthenticationEntryPoint 处理规则3: 如果异常是 AccessDeniedException 且用户不是匿名用户，如果否则交给 AccessDeniedHandler 处理 对应以下代码 1234567891011121314151617181920212223private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) throws IOException, ServletException &#123; if (exception instanceof AuthenticationException) &#123; logger.debug( "Authentication exception occurred; redirecting to authentication entry point", exception); sendStartAuthentication(request, response, chain, (AuthenticationException) exception); &#125; else if (exception instanceof AccessDeniedException) &#123; if (authenticationTrustResolver.isAnonymous(SecurityContextHolder.getContext().getAuthentication())) &#123; logger.debug("Access is denied (user is anonymous); redirecting to authentication entry point", exception); sendStartAuthentication(request, response, chain, new InsufficientAuthenticationException("Full authentication is required to access this resource")); &#125; else &#123; logger.debug( "Access is denied (user is not anonymous); delegating to AccessDeniedHandler", exception); accessDeniedHandler.handle(request, response, (AccessDeniedException) exception); &#125; &#125;&#125; AccessDeniedHandler 默认实现是 AccessDeniedHandlerImpl。该类对异常的处理是返回403错误码。 12345678910111213141516171819202122public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; if (!response.isCommitted()) &#123; if (errorPage != null) &#123; // 定义了errorPage // errorPage中可以操作该异常 request.setAttribute(WebAttributes.ACCESS_DENIED_403, accessDeniedException); // 设置403状态码 response.setStatus(HttpServletResponse.SC_FORBIDDEN); // 转发到errorPage RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage); dispatcher.forward(request, response); &#125; else &#123; // 没有定义errorPage，则返回403状态码(Forbidden)，以及错误信息 response.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedException.getMessage()); &#125; &#125;&#125; AuthenticationEntryPoint 默认实现是 LoginUrlAuthenticationEntryPoint, 该类的处理是转发或重定向到登录页面 1234567891011121314151617181920212223242526272829303132333435363738public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; String redirectUrl = null; if (useForward) &#123; if (forceHttps &amp;&amp; "http".equals(request.getScheme())) &#123; // First redirect the current request to HTTPS. // When that request is received, the forward to the login page will be // used. redirectUrl = buildHttpsRedirectUrlForRequest(request); &#125; if (redirectUrl == null) &#123; String loginForm = determineUrlToUseForThisRequest(request, response, authException); if (logger.isDebugEnabled()) &#123; logger.debug("Server side forward to: " + loginForm); &#125; RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm); // 转发 dispatcher.forward(request, response); return; &#125; &#125; else &#123; // redirect to login page. Use https if forceHttps true redirectUrl = buildRedirectUrlToLoginPage(request, response, authException); &#125; // 重定向 redirectStrategy.sendRedirect(request, response, redirectUrl);&#125; 了解完这些，回到我们的例子。 第3步时，用户未登录的情况下访问受保护资源，ExceptionTranslationFilter 会捕获到 AuthenticationException 异常(规则1)。页面需要跳转，ExceptionTranslationFilter 在跳转前使用 requestCache 缓存 request。 1234567891011protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) throws ServletException, IOException &#123; // SEC-112: Clear the SecurityContextHolder's Authentication, as the // existing Authentication is no longer considered valid SecurityContextHolder.getContext().setAuthentication(null); // 缓存 request requestCache.saveRequest(request, response); logger.debug("Calling Authentication entry point."); authenticationEntryPoint.commence(request, response, reason);&#125; 一些坑在开发过程中，如果不理解 Spring Security 如何缓存 request，可能会踩一些坑。 举个简单例子，如果网站认证是信息存放在 header 中。第一次请求受保护资源时，请求头中不包含认证信息 ，验证失败，该请求会被缓存，之后即使用户填写了信息，也会因为request被恢复导致信息丢失从而认证失败(问题描述可以参见这里。 最简单的方案当然是不缓存request。 spring security 提供了 NullRequestCache， 该类实现了 RequestCache 接口，但是没有任何操作。 12345678910111213141516171819public class NullRequestCache implements RequestCache &#123; public SavedRequest getRequest(HttpServletRequest request, HttpServletResponse response) &#123; return null; &#125; public void removeRequest(HttpServletRequest request, HttpServletResponse response) &#123; &#125; public void saveRequest(HttpServletRequest request, HttpServletResponse response) &#123; &#125; public HttpServletRequest getMatchingRequest(HttpServletRequest request, HttpServletResponse response) &#123; return null; &#125;&#125; 配置 requestCache，使用如下代码即可: 1http.requestCache().requestCache(new NullRequestCache()); 补充默认情况下，三种 request 不会被缓存。 请求地址以 /favicon.ico 结尾 header中的 content-type 值为 application/json header中的 X-Requested-With 值为 XMLHttpRequest 可以参见：RequestCacheConfigurer 类中的私有方法 createDefaultSavedRequestMatcher。 附上实例代码: https://coding.net/u/tanhe123/p/SpringSecurityRequestCache]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
</search>
